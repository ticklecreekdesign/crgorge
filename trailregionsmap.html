<!-- MAP WRAPPER (Hostinger needs an explicit height) -->
<div id="crg-map-wrap" style="width:100%; max-width:1400px; margin:0 auto;">
  <div id="map" style="width:100%; height:770px; border:1px solid #CCCCCC;"></div>
</div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  /* optional: make the map shorter on mobile */
  @media (max-width: 768px){
    #map{ height:545px !important; }
  }

  .region-label-wrapper{
    background: transparent !important;
    border: none !important;
    transform: translate(-50%, -50%);
  }

  .region-label-text{
    color:#000;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    text-align:center;
    line-height:1.12;
    white-space:nowrap;
  }

  /* Keep these, but inline styles will enforce size */
  .region-label-text .mp{
    font-size:12px !important;
    font-weight:400 !important;
  }
  .region-label-text .name{
    font-size:12px !important;
    font-weight:400 !important;
    letter-spacing:0.8px;
  }

  /* Button under zoom controls */
  .leaflet-control-open-full a{
    width:34px;
    height:34px;
    line-height:34px;
    text-align:center;
    font-size:18px;
    display:block;
    text-decoration:none;
    color:#333;
    background:#fff;
  }
  .leaflet-control-open-full a:hover{ background:#f4f4f4; }
</style>

<script>
(function(){
  // If Hostinger re-renders blocks, prevent double-init
  if (window.__CRG_MAP_INIT__) return;
  window.__CRG_MAP_INIT__ = true;

  const params = new URLSearchParams(window.location.search);
  const unrestricted = params.get('unrestricted') === '1';
  const defaultZoom = 10;

  const map = L.map('map', {
    center: [45.62, -121.6],
    zoom: defaultZoom,
    minZoom: unrestricted ? 0 : defaultZoom,
    zoomControl: true
  });

  // Force proper sizing once the embed block has laid out
  function fixSize(){ map.invalidateSize(true); }
  setTimeout(fixSize, 50);
  setTimeout(fixSize, 200);
  window.addEventListener('resize', () => setTimeout(fixSize, 100));

  L.tileLayer(
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',
    { attribution: 'Tiles &copy; Esri', maxZoom: 19 }
  ).addTo(map);

  // Open unrestricted map in new window (no restrictions) preserving view
  if (!unrestricted) {
    const OpenFullControl = L.Control.extend({
      options: { position: 'topleft' },
      onAdd: function() {
        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-open-full');
        const link = L.DomUtil.create('a', '', container);
        link.href = '#';
        link.title = 'Open full map in a new window';
        link.setAttribute('aria-label', 'Open full map in a new window');
        link.innerHTML = '⤢';

        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.on(link, 'click', (e) => {
          L.DomEvent.preventDefault(e);
          const c = map.getCenter();
          const z = map.getZoom();
          const url = new URL(window.location.href);
          url.searchParams.set('unrestricted', '1');
          url.searchParams.set('lat', c.lat.toFixed(6));
          url.searchParams.set('lng', c.lng.toFixed(6));
          url.searchParams.set('z', String(z));
          window.open(url.toString(), '_blank', 'noopener');
        });

        return container;
      }
    });
    new OpenFullControl().addTo(map);
  }

  const colors = {
    west: '#1B5E20',
    centralWest: '#2E7D32',
    central: '#558B2F',
    centralEast: '#9E9D24',
    east: '#C0CA33'
  };

  const OR = [
    [45.542793, -122.357188],
    [45.594439, -122.069067],
    [45.693033, -121.788757],
    [45.708906, -121.490056],
    [45.607299, -121.197596],
    [45.635525, -120.911525]
  ];

  const WA = [
    [45.57168228259249, -122.31767443196766],
    [45.59242347354461, -122.07760326175781],
    [45.61316466449673, -121.83753209154797],
    [45.63390585544885, -121.59746092133812],
    [45.65464704640097, -121.35738975112828],
    [45.67538823737303, -120.87730858090842]
  ];

  const regions = [
    { name: 'West',         orMp: '19–34',  waMp: '16–32',  color: colors.west,        leftOR: OR[0], rightOR: OR[1], leftWA: WA[0], rightWA: WA[1] },
    { name: 'Central West', orMp: '34–50',  waMp: '32–50',  color: colors.centralWest, leftOR: OR[1], rightOR: OR[2], leftWA: WA[1], rightWA: WA[2] },
    { name: 'Central',      orMp: '50–65',  waMp: '50–65',  color: colors.central,     leftOR: OR[2], rightOR: OR[3], leftWA: WA[2], rightWA: WA[3] },
    { name: 'Central East', orMp: '65–84',  waMp: '65–81',  color: colors.centralEast, leftOR: OR[3], rightOR: OR[4], leftWA: WA[3], rightWA: WA[4] },
    { name: 'East',         orMp: '84–100', waMp: '81–96',  color: colors.east,        leftOR: OR[4], rightOR: OR[5], leftWA: WA[4], rightWA: WA[5] }
  ];

  const fadeSteps = 15;
  const fadeExtension = 0.15;
  const baseOpacity = 0.35;

  const outline = `
    text-shadow:
      1px 1px 0 #fff,
     -1px 1px 0 #fff,
      1px -1px 0 #fff,
     -1px -1px 0 #fff,
      0  2px 0 #fff,
      0 -2px 0 #fff,
      2px 0  0 #fff,
     -2px 0  0 #fff;
  `;

  regions.forEach(region => {
    const leftLng = (region.leftOR[1] + region.leftWA[1]) / 2;
    const rightLng = (region.rightOR[1] + region.rightWA[1]) / 2;

    const northLat = Math.max(region.leftWA[0], region.rightWA[0], region.leftOR[0], region.rightOR[0]);
    const southLat = Math.min(region.leftWA[0], region.rightWA[0], region.leftOR[0], region.rightOR[0]);

    // main fill
    L.polygon([
      [southLat, leftLng],
      [southLat, rightLng],
      [northLat, rightLng],
      [northLat, leftLng]
    ], { color:'transparent', weight:0, fillColor:region.color, fillOpacity:baseOpacity }).addTo(map);

    // fade north
    for (let i = 1; i <= fadeSteps; i++) {
      const fadeStart = northLat + (fadeExtension / fadeSteps) * (i - 1);
      const fadeEnd = northLat + (fadeExtension / fadeSteps) * i;
      const opacity = baseOpacity * (1 - i / fadeSteps);

      L.polygon([[fadeStart,leftLng],[fadeStart,rightLng],[fadeEnd,rightLng],[fadeEnd,leftLng]],
        { color:'transparent', weight:0, fillColor:region.color, fillOpacity:opacity }).addTo(map);
    }

    // fade south
    for (let i = 1; i <= fadeSteps; i++) {
      const fadeStart = southLat - (fadeExtension / fadeSteps) * (i - 1);
      const fadeEnd = southLat - (fadeExtension / fadeSteps) * i;
      const opacity = baseOpacity * (1 - i / fadeSteps);

      L.polygon([[fadeStart,leftLng],[fadeStart,rightLng],[fadeEnd,rightLng],[fadeEnd,leftLng]],
        { color:'transparent', weight:0, fillColor:region.color, fillOpacity:opacity }).addTo(map);
    }

    // boundary lines
    const lineSteps = 20;
    const verticalExtent = 0.25;

    const leftCenterLat = (region.leftOR[0] + region.leftWA[0]) / 2;
    const rightCenterLat = (region.rightOR[0] + region.rightWA[0]) / 2;

    for (let i = 0; i < lineSteps; i++) {
      const t1 = i / lineSteps, t2 = (i + 1) / lineSteps;
      const lat1 = (leftCenterLat - verticalExtent) + t1 * (verticalExtent * 2);
      const lat2 = (leftCenterLat - verticalExtent) + t2 * (verticalExtent * 2);
      const avgDist = (Math.abs(lat1-leftCenterLat)+Math.abs(lat2-leftCenterLat))/2;
      const opacity = Math.max(0.1, 1 - (avgDist / verticalExtent) * 0.9);
      L.polyline([[lat1,leftLng],[lat2,leftLng]], { color:'#888', weight:2, opacity }).addTo(map);
    }

    for (let i = 0; i < lineSteps; i++) {
      const t1 = i / lineSteps, t2 = (i + 1) / lineSteps;
      const lat1 = (rightCenterLat - verticalExtent) + t1 * (verticalExtent * 2);
      const lat2 = (rightCenterLat - verticalExtent) + t2 * (verticalExtent * 2);
      const avgDist = (Math.abs(lat1-rightCenterLat)+Math.abs(lat2-rightCenterLat))/2;
      const opacity = Math.max(0.1, 1 - (avgDist / verticalExtent) * 0.9);
      L.polyline([[lat1,rightLng],[lat2,rightLng]], { color:'#888', weight:2, opacity }).addTo(map);
    }

    // label placement
    const centerLat = (leftCenterLat + rightCenterLat) / 2;
    const centerLng = (leftLng + rightLng) / 2;

    // ✅ Inline styles guarantee the font size changes apply
    const label = L.divIcon({
      className: 'region-label-wrapper',
      html: `
        <div class="region-label-text" style="text-align:center; line-height:1.12; white-space:nowrap; color:#000;">
          <div class="mp" style="font-size:12px; font-weight:400;">WA ${region.waMp}</div>
          <div class="name" style="font-size:12px; font-weight:400; letter-spacing:0.8px; ${outline}">
            ${region.name.toUpperCase()}
          </div>
          <div class="mp" style="font-size:12px; font-weight:400;">OR ${region.orMp}</div>
        </div>
      `,
      iconSize: [160, 56],
      iconAnchor: [80, 28]
    });

    L.marker([centerLat, centerLng], { icon: label, interactive: false }).addTo(map);
  });
})();
</script>
